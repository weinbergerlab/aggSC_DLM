################################################################################
# Incorporating information on control diseases across space and time to       #
# improve estimation of the population-level impact of vaccines                #
#                                                                              # 
# Authors: Kayoko Shioda, Jiachen Cai, Joshua L Warren, Daniel M Weinberger    #
################################################################################

#------------------------------------------------------------------------------#
# Description
#------------------------------------------------------------------------------#

# R script to fit the synthetic control model for Approach 1 
# (Simple aggregation across *time*)

rm(list = ls(all = TRUE))

#------------------------------------------------------------------------------#
# Select the aggregation level for controls and age group and load the dataset
#------------------------------------------------------------------------------#

####################### Select #######################
agglvl <- "Month" # Month, Quarter, Semester, or Year
AgeGrp <- "08" # "08" for 80+yo or "09" for <12mo
rand.eff <- "IID" # IID or AR1
######################################################

# Import Brazil state-level hospitalization data (Aggregated control diseases)
Brazil_data <- read.csv(file=paste0("~/Approach1_SimpleAggregation/Data/BrazilHosp_Age", 
                                    AgeGrp, "_By", agglvl, ".csv"), as.is = T)

#------------------------------------------------------------------------------#
# Set up
#------------------------------------------------------------------------------#

# Load packages
library(lubridate)
library(HDInterval)
library(beepr)
library(ggplot2)
library(parallel)
library(pbapply)

# Replace the aggregated "pandemic" variable with the original one in the monthly data.
monthlydata <- read.csv(file=paste0("~/Approach1_SimpleAggregation/Data/BrazilHosp_Age", 
                                    AgeGrp, "_ByMonth.csv"), as.is = T)
Brazil_data$pandemic <- monthlydata$pandemic

# Set up the date variables 
start_date        <- as.Date('2004-07-01') # Indicates the date of the first data point (Removed Jan-Jun 2004 to make results comparable to those generated by the temporal DLM)
intervention_date <- as.Date('2010-02-28') # Indicates the date of PCV introduction in the data (-1 day)
end_date          <- as.Date('2014-12-01') # Indicates the date of the last data point
pre_period        <- as.Date(c('2004-07-01', '2010-02-28')) # Range over which the data is trained for the CausalImpact model (Removed Jan-Jun 2004 to make results comparable to those generated by the temporal DLM)
post_period       <- as.Date(c('2010-03-01', '2014-12-01')) # Range from the PCV introduction date to the end date
eval_period       <- as.Date(c('2011-03-01', '2014-12-01')) # Range over which rate ratio calculation will be performed

# Set variable names as follows 
group_name   <- 'age_group' # Name of column containing group labels
date_name    <- 'date'      # Name of column containing dates
outcome_name <- 'J12_18'    # Name of column containing outcome
denom_name   <- 'ach_noj'   # Name of column containing denominator to be used in offset

# Load functions
formatDate <- function(time_points) {
 time_points <- as_date(time_points)
 time_points <- as.Date(time_points, format = '%Y-%m-%d')
 return(time_points)
}
splitGroup <- function(ungrouped_data, group_name, group, date_name, start_date, end_date, no_filter = NULL) {
 ds <- ungrouped_data[ungrouped_data[, group_name] == group, ]
 ds <- ds[, colSums(is.na(ds)) == 0]
 ds <- ds[match(start_date, ds[, date_name]):match(end_date, ds[, date_name]), ]
 # ds <- cbind(ds[, colnames(ds) %in% no_filter], filterSparse(ds[, !(colnames(ds) %in% no_filter), drop=FALSE]))
 return(ds)
}

# Remove regional and national data (or select specific state(s)) for analysis
prelog_data <- Brazil_data
prelog_data <- prelog_data[substr(prelog_data$age_group,6,7) != "AA", ] # Remove regional and national level data.

# Split data into a list by state (age_group)
groups <- as.character(unique(unlist(prelog_data[, group_name], use.names = FALSE)))
prelog_data[, date_name] <- formatDate(prelog_data[, date_name])
prelog_data <- setNames(lapply(groups, 
                               FUN = splitGroup, 
                               ungrouped_data = prelog_data, 
                               group_name = group_name, 
                               date_name = date_name, 
                               start_date = start_date, 
                               end_date = end_date, 
                               no_filter = names(Brazil_data)), 
                        groups)

#------------------------------------------------------------------------------#
# Create a function to run the synthetic control (SC) model in JAGS
#------------------------------------------------------------------------------#

call.jags.mod <- function(ds.in, rand.eff) {
 
 #-----*-----*-----*-----*-----*-----*-----*-----#
 # Set up                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           et up for each state
 #-----*-----*-----*-----*-----*-----*-----*-----#
 
 # x is a data frame with control diseases
 x <- subset(ds.in, select = -c(age_group, date, J12_18, pandemic)) # Drop age_group, date, J12_18 (outcome), and pandemic
 x.scale <- x
 
 # Reformat the dataset
 y <- ds.in[,'J12_18']
 y.pre <- y[ds.in$date < post_period[1]]
 ds2 <- cbind.data.frame(y, x.scale)
 names(ds2) <- c('J12_18', names(x))
 ds2.pre <- ds2[ds.in$date < post_period[1],]
 ds3 <- ds2
 ds3$J12_18[ds.in$date >= post_period[1]] <- NA
 
 # Create monthly dummy variables to control for seasonality
 months <- month(ds.in$date)
 month.mat <- dummies::dummy(months)
 month.mat <- month.mat[,-12]
 month.mat <- cbind(rep(1, nrow(month.mat)), month.mat, ds.in$pandemic) # Add an intercept
 colnames(month.mat) <- c("Intercept","s1","s2","s3","s4","s5","s6","s7","s8","s9","s10","s11","pandemic")
 month.mat.pre <- month.mat[ds.in$date < post_period[1], ]
 
 #-----*-----*-----*-----*-----*-----*-----*-----#
 # Run SC model with horseshoe priors in JAGS
 #-----*-----*-----*-----*-----*-----*-----*-----#
 
 # Select the model
 if (rand.eff=="AR1") {
  mod.txt <- source('~/Approach1_SimpleAggregation/Rcode/Non_spatial-Non_lagged-AR1_KS.R') 
 } else if (rand.eff=="IID") {
  mod.txt <- source('~/Approach1_SimpleAggregation/Rcode/Non_spatial-Non_lagged-independent_KS2.R') 
 }
 
 res_state <- nonspace_nonlag(burnin= 200000, 
                              samples=400000, 
                              thin=40,
                              chains=2,
                              regularize=TRUE,
                              dic=TRUE,
                              n_full=length(ds3$J12_18), # The length of “y_modeling” + how far you want to predict out
                              n_modeling=length(y.pre), # The length of the “y_modeling” vector
                              y_modeling=ds3$J12_18,
                              offset=rep(0, length(y)) ,
                              z=month.mat,  # Parameters not being shrunk. Must have number of rows = n_full (for model fitting and prediction)
                              x=x.scale # Must have number of rows = n_full (for model fitting and prediction)
 )
}


#------------------------------------------------------------------------------#
# Parallelize JAGS and run the model
#------------------------------------------------------------------------------#

# Set up
n_cores <- detectCores() - 1
cl <- makeCluster(n_cores)

# Run JAGS in parallel
clusterEvalQ(cl, {
 library(lubridate, quietly = TRUE)
 library(HDInterval, quietly = TRUE)
})
clusterExport(cl, c('call.jags.mod','post_period'), environment())
res_state <- pblapply(cl = cl, X=prelog_data, FUN=call.jags.mod, rand.eff=rand.eff)

# Stop the cluster
stopCluster(cl)

names(res_state) <- groups

